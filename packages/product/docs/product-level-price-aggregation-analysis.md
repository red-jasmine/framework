# 商品级别价格汇总表方案分析

## 方案概述

在价格子领域中添加一个**商品级别价格汇总表**（`product_level_prices`），记录商品在不同价格维度下的变体价格统计信息，用于优化商品列表查询性能。

## 表结构设计

```sql
CREATE TABLE `product_level_prices` (
    `id` BIGINT UNSIGNED PRIMARY KEY COMMENT '汇总价格ID',
    `product_id` BIGINT UNSIGNED NOT NULL COMMENT '商品ID',
    
    -- 价格维度（与 product_prices 表一致）
    `market` VARCHAR(64) DEFAULT '*' COMMENT '市场',
    `store` VARCHAR(64) DEFAULT '*' COMMENT '门店',
    `user_level` VARCHAR(32) DEFAULT '*' COMMENT '用户等级',
    
    -- 价格统计信息
    `currency` CHAR(3) NOT NULL COMMENT '货币',
    `avg_price` DECIMAL(12, 2) COMMENT '变体均价',
    `min_price` DECIMAL(12, 2) COMMENT '最低价',
    `max_price` DECIMAL(12, 2) COMMENT '最高价',
    `default_variant_price` DECIMAL(12, 2) COMMENT '默认变体价格',
    `variant_count` INT DEFAULT 0 COMMENT '变体数量',
    
    -- 市场价和成本价统计
    `avg_market_price` DECIMAL(12, 2) NULL COMMENT '平均市场价',
    `avg_cost_price` DECIMAL(12, 2) NULL COMMENT '平均成本价',
    
    -- 元数据
    `last_calculated_at` TIMESTAMP NULL COMMENT '最后计算时间',
    `operator_id` BIGINT UNSIGNED NULL COMMENT '操作人ID',
    `created_at` TIMESTAMP NULL,
    `updated_at` TIMESTAMP NULL,
    `deleted_at` TIMESTAMP NULL,
    
    -- 索引
    INDEX `idx_product_dimensions` (`product_id`, `market`, `store`, `user_level`),
    INDEX `idx_dimensions` (`market`, `store`, `user_level`)
) COMMENT='商品级别价格汇总表';
```

## 优点分析

### 1. **查询性能大幅提升** ⭐⭐⭐⭐⭐
- **当前方案**：需要查询商品表 → 查询变体表 → 查询价格表（3个表，可能多次查询）
- **新方案**：只需要查询商品表 → 查询汇总表（2个表，1次JOIN）
- **性能提升**：查询时间从 O(n*m) 降低到 O(n)，其中 n=商品数量，m=平均变体数量

### 2. **减少数据库查询次数** ⭐⭐⭐⭐⭐
- **当前方案**：
  - 查询商品列表：1次
  - 批量查询默认变体：1次
  - 批量查询价格：1次
  - 总计：3次查询
- **新方案**：
  - 查询商品列表（JOIN汇总表）：1次
  - 总计：1次查询
- **减少查询次数**：从 3次 减少到 1次

### 3. **减少内存占用** ⭐⭐⭐⭐
- 不需要加载所有变体数据
- 不需要加载所有变体价格数据
- 只加载汇总后的价格信息
- **内存节省**：假设每个商品有10个变体，内存占用减少约 90%

### 4. **简化查询逻辑** ⭐⭐⭐⭐
- 查询逻辑从复杂的多表关联简化为简单的JOIN
- 代码更简洁，易于维护
- 减少业务逻辑复杂度

### 5. **支持灵活的展示需求** ⭐⭐⭐
- 可以展示均价、最低价、最高价
- 可以展示价格区间（如：¥99-¥199）
- 满足不同业务场景的需求

### 6. **索引优化效果好** ⭐⭐⭐⭐
- 汇总表数据量远小于价格表（商品数量 << 变体数量）
- 索引效率更高
- 查询速度更快

## 缺点分析

### 1. **数据一致性问题** ⭐⭐⭐⭐⭐（严重）
- **问题**：当变体价格变化时，需要同步更新汇总表
- **风险**：
  - 如果更新失败，汇总表数据可能不准确
  - 需要保证事务一致性
  - 分布式环境下更难保证一致性
- **解决方案**：
  - 使用数据库事务
  - 使用事件监听器自动更新
  - 定期校验和修复数据

### 2. **实时性问题** ⭐⭐⭐⭐（重要）
- **问题**：汇总表是预计算的，可能存在延迟
- **场景**：
  - 价格更新后，汇总表可能还未更新
  - 新变体添加后，汇总表可能还未计算
- **解决方案**：
  - 同步更新（实时计算，性能开销大）
  - 异步更新（延迟更新，性能好但可能不实时）
  - 混合方案（关键操作同步，非关键操作异步）

### 3. **灵活性降低** ⭐⭐⭐（中等）
- **问题**：只能获取汇总价格，无法获取具体变体价格
- **限制**：
  - 商品列表页只能显示均价/最低价/最高价
  - 无法在列表页显示具体变体的价格
  - 需要查看详情页才能看到具体变体价格
- **影响**：如果业务需要显示具体变体价格，此方案不适用

### 4. **存储成本增加** ⭐⭐（轻微）
- **问题**：需要额外的存储空间
- **计算**：
  - 假设有 10,000 个商品
  - 每个商品有 3 个价格维度组合（market × store × user_level）
  - 总计：10,000 × 3 = 30,000 条记录
  - 每条记录约 200 字节
  - 总计：约 6MB（可忽略不计）

### 5. **维护成本增加** ⭐⭐⭐（中等）
- **问题**：需要额外的代码来维护汇总表
- **成本**：
  - 价格更新时需要更新汇总表
  - 变体添加/删除时需要更新汇总表
  - 需要定期校验数据一致性
  - 需要处理异常情况（如更新失败）

### 6. **计算逻辑复杂度** ⭐⭐⭐（中等）
- **问题**：需要定义如何计算均价、最低价、最高价
- **挑战**：
  - 如何处理没有价格的变体？
  - 如何处理不同货币的变体？
  - 如何处理已删除的变体？
  - 如何处理阶梯价格？

### 7. **维度组合爆炸** ⭐⭐（轻微）
- **问题**：价格维度组合可能很多
- **计算**：
  - market: 3个值（cn, us, de, *）
  - store: 10个值（default, store_1, ..., store_9, *）
  - user_level: 5个值（default, vip, gold, platinum, *）
  - 组合数：4 × 11 × 5 = 220 种组合
- **影响**：每个商品最多可能有 220 条汇总记录
- **缓解**：实际使用中，大部分商品不会配置所有组合

## 实现方案建议

### 方案A：完全同步更新（实时性最好，性能较差）
```php
// 在价格更新时同步更新汇总表
public function updatePrice(ProductPrice $price)
{
    DB::transaction(function () use ($price) {
        // 更新价格
        $price->save();
        
        // 同步更新汇总表
        $this->recalculateProductLevelPrice(
            $price->product_id,
            $price->market,
            $price->store,
            $price->user_level
        );
    });
}
```

### 方案B：异步更新（性能最好，实时性较差）
```php
// 使用队列异步更新汇总表
public function updatePrice(ProductPrice $price)
{
    $price->save();
    
    // 异步更新汇总表
    RecalculateProductLevelPriceJob::dispatch(
        $price->product_id,
        $price->market,
        $price->store,
        $price->user_level
    );
}
```

### 方案C：混合方案（推荐）
```php
// 关键操作同步更新，非关键操作异步更新
public function updatePrice(ProductPrice $price, bool $sync = false)
{
    $price->save();
    
    if ($sync) {
        // 同步更新（用于关键操作）
        $this->recalculateProductLevelPrice(...);
    } else {
        // 异步更新（用于批量操作）
        RecalculateProductLevelPriceJob::dispatch(...);
    }
}
```

### 方案D：定期全量计算（最简单，实时性最差）
```php
// 定期（如每小时）全量重新计算所有汇总价格
// 适合对实时性要求不高的场景
```

## 适用场景

### ✅ 适合使用汇总表的场景
1. **商品列表页**：只需要显示价格范围或均价
2. **搜索页面**：按价格区间筛选商品
3. **分类页面**：展示商品价格概览
4. **推荐页面**：展示商品价格信息
5. **高并发场景**：需要快速响应，对实时性要求不高

### ❌ 不适合使用汇总表的场景
1. **商品详情页**：需要显示所有变体的具体价格
2. **购物车页面**：需要显示选中变体的精确价格
3. **订单页面**：需要显示订单中变体的精确价格
4. **价格实时性要求高的场景**：如秒杀、限时折扣等

## 推荐方案

### 混合方案：汇总表 + 原有价格表

1. **商品列表查询**：使用汇总表（快速、高效）
2. **商品详情查询**：使用原有价格表（精确、实时）
3. **价格更新**：同步更新汇总表（保证一致性）
4. **定期校验**：定期校验汇总表数据准确性

### 实现步骤

1. **创建汇总表**：`product_level_prices`
2. **创建汇总服务**：`ProductLevelPriceService`
3. **创建更新监听器**：监听价格变化事件，自动更新汇总表
4. **创建校验任务**：定期校验和修复汇总表数据
5. **修改查询逻辑**：商品列表查询使用汇总表

## 总结

### 优点评分：⭐⭐⭐⭐（4/5）
- 查询性能大幅提升
- 减少数据库查询次数
- 减少内存占用
- 简化查询逻辑

### 缺点评分：⭐⭐⭐（3/5）
- 数据一致性问题需要妥善处理
- 实时性问题需要权衡
- 灵活性有所降低

### 总体评价

**推荐采用此方案**，但需要注意：
1. 必须实现可靠的数据同步机制
2. 需要权衡实时性和性能
3. 需要定期校验数据一致性
4. 适合商品列表等对实时性要求不高的场景

### 建议

1. **先实现汇总表**，用于商品列表查询
2. **保留原有价格表**，用于商品详情等需要精确价格的场景
3. **实现混合查询策略**：列表用汇总表，详情用价格表
4. **实现数据同步机制**：确保汇总表数据准确性
5. **实现数据校验机制**：定期校验和修复数据

